\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english,greek]{babel}
\babeltags{en = english}
\babeltags{gr = greek}
\usepackage{fullpage,enumitem,amsmath,amssymb,graphicx}
\usepackage{alphabeta}
\usepackage{blindtext}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{tikz-3dplot,pgfplots}
\usepackage{wrapfig}
\usepackage[]{hyperref}
\begin{document}

\begin{center}
{\LARGE Προχωρημένα Θέματα Βάσεων Δεδομένων}

\begin{tabular}{rl}
Ονοματεπώνυμο: & Μπάρμπα Παναγιώτα-Νικολέττα \\
ΑΜ : & 03118604 \\
Εξάμηνο : & 11ο \\
Ομάδα : 41 \\
\texten{Github} : & \href{https://github.com/NicoleMp2/advDatabases}{Github Link} \\
\end{tabular}
\end{center}



\section*{Ζητούμενο 1:}

\par Η εγκατάσταση και διαμόρφωση της πλατφόρμας εκτέλεσης Apache Spark ώστε να εκτελείται πάνω από το διαχειριστή πόρων του Apache Hadoop, YARN, έγινε σε 2 εικονικά μηχανήματα σε τοπικό μηχάνημα (δεν χρησιμοποιήθηκε το \texten{cloud service okeanos}). 
\par Οι \texten{web} διεπαφές των \texten{Apache Spark} και \texten{Apache Hadoop} είναι προσβάσιμες από τους παρακάτω συνδέσμους:
\begin{itemize}
  \item \texten{Apache Spark} : \href{http://192.168.64.9:8080/}{http://192.168.64.9:8080/}
  \item \texten{Apache Hadoop} : \href{http://192.168.64.9:9870/}{http://192.168.64.9:9870/}
  \item \texten{Apache Hadoop YARN} : \href{http://192.168.64.9:8088/}{http://192.168.64.9:8088/}
\end{itemize}


\section*{Ζητούμενο 3: Συντομότερα Μονοπάτια με Συντομεύσεις Ενδιάμεσων Ακμών}

\begin{enumerate}
  \item Δημιουργούμε ένα αντίγραφο $G'$ του αρχικού γραφήματος $G$, εάν δύο κορυφές $u$ και $v$ συνδέονται στο αρχικό γράφο ως $u \rightarrow v$ θα συνδέσουμε την $u$ με την $v'$,δηλαδή το αντίγραφο της $v$ στον $G'$ ως $u \rightarrow v'$. Επαναλαμβάνουμε την διαδικασία για κάθε ακμή του αρχικού γραφήματος $G$ και τελικά οδηγούμαστε σε ένα γράφο με πλήθος κορυφών $2n$ και πλήθος ακμών $2m + m$. Τέλος, εφαρμόζουμε \texten{Dijkstra} στον νέο γράφο με σκοπό να βρούμε το συντομότερο μονομάτι από τον κόμβο $s$, τώρα στον νέο κόμβο $t'$. \\
  Συνολική πολυπλοκότητα: $O(3m + 2nlogn)= O(m + nlogn) = O(Dijkstra)$ \\
  \begin{figure}[h]
    \includegraphics[width=10cm,height=7cm]{Screenshot 2023-12-29 at 19.50.06.png}
    \centering
  \end{figure}
  % \begin{center}
  %   \begin{tikzpicture}[node distance={15mm}, thick, main/.style = {draw, circle}] 
  %   \node[main] (1) {$s$}; 
  %   \node[main] (2) [above right of=1] {$v_1$}; 
  %   \node[main] (3) [below right of=1] {$v_2$}; 
  %   \node[main] (4) [right of=3] {$v_3$}; 
  %   \node[main] (5) [right of=2] {$t$}; 
  %   \node[main] (6) [above right of=4] {$s'$}; 
  %   \node[main] (7) [above right of=6] {$v'_1$}; 
  %   \node[main] (8) [below right of=6] {$v'_2$}; 
  %   \node[main] (9) [right of=8] {$v'_3$}; 
  %   \node[main] (10) [right of=7] {$t'$}; 
  %   \draw[->] (1) -- (2); 
  %   \draw[->] (1) -- (3); 
  %   \draw[->] (1) to [out=135,in=90,looseness=1.5] (7);
  %   \draw[->] (1) to [out=135,in=90,looseness=1.5] (8); 
  %   \draw[->] (2) -- (4); 
  %   \draw[->] (3) -- (4); 
  %   \draw[->] (5) -- (4); 
  %   % \draw[->] (6) -- node[midway, above right, sloped, pos=1] {+1} (4); 
  %   \end{tikzpicture} 
  % \end{center}
  \item 
  Εδώ η λύση είναι ισοδύναμη με του ερωτήματος 1. Θα δημιουργήσουμε k συνεχόμενα αντίγραφα $G_i$ με $1 \leq i \leq k$ του αρχικού γραφήματος $G$ (έστω ότι ο αρχικός γράφος είναι ο G0 και ο τελικός γράφος ο Gk με τον κόμβο-στόχο tk). Τώρα θέλουμε να δημιουργήσουμε μια "αλυσίδα" από αντίγραφα του γράφου G, συνδέοντας κάθε κορυφή του $G_{i-1}$ με κάθε κορυφή του Gi με ακμή βάρους 0 αν και μόνο αν αυτές οι δύο συνδέονται στον γράφο $G$ με κάποιο θετικό βάρος. Τώρα τρέχουμε πάλι $Dijkstra$ στον συνολικό γράφο με στόχο να βρούμε το συντομότερο μονοπάτι από τον $s$ στον $t_k$, το οποίο θα περιλαμβάνει ακριβώς $k$
  μηδενισμούς βαρών $k$ ακμών του μονοπατιού.
  Σε αυτή την υλοποίηση έχουμε $k+1$ γράφους με n κορυφές και m ακμές άρα $(k+1)n$ κορυφές και $(k+1)m$ ακμές. Για τις ενδιάμεσες ακμές έχουμε $km$ ακμές. ΄Αρα η εκτέλεση
  του αλγορίθμου αντιστοιχεί σε χρονική πολυπλότητα του $Dijkstra$ για kn κορυφές και km
  ακμές, δηλαδή $O(km + kn(log(kn)))$
\end{enumerate}

\section*{Ζητούμενο 4: Ταξίδι σε Περίοδο Ενεργειακής Κρίσης}

\begin{enumerate}
    \item Καταρχάς αν $\exists e \in E : b(e) > B$, δεν μπορούμε να φτάσουμε στην πόλη $t$. Αυτός ο έλεγχος γίνεται εύκολα σε χρόνο $O(n)$. Θεωρούμε ότι είναι δυνατή η μετάβαση στην πόλη $t$. Τροποποιούμε τον αλγόριθμο εύρεσης κυρίαρχης θέσης που διατυπώσαμε στην πρώτη
    σειρά ασκήσεων. Εφαρμόζουμε τον παρακάτω αλγόριθμο στον πίνακα $c[1..n]$ (όπου χρησιμοποιούμε την σύντμηση $c[i] = c[u_i]$ και $u_1:= s, u_n =t$) και αποθηκεύουμε τα αποτελέσματα στον $d[1..n]$ :\\
    $ClosestRightCheaper( c[1..n] ):$\\
    $ \hookrightarrow d[1..n- 1] \leftarrow 1, 2, ..., n- 1, s \leftarrow stack(NULL)$\\
    $\hookrightarrow$ Για $i$ από $n - 1$ έως 1:\\
    • \texten{s.push(i + 1)} \\
    • Όσο $s\neq $ κενή:\\
    - Αν $c[u_i] \leq c[u_{s.top()}]$, τότε $s.pop()$\\
    - Αλλιώς $break$\\
    • $d[i] \leftarrow s.top()$\\ $return d[1..n]$ \\
    Μετά το πέρας του αλγορίθμου ισχύει:
    \begin{center}
      \[ d[i]=arg
      \left\{
      \begin{array}{ll}
        min_{c[j]<c[i]_{j>i}}(j-i) 
      \end{array} 
      \right\}. 
      \]
    \end{center}
    Πιο απλά στο $d[i]$ βρίσκεται η κοντινότερη θέση j "δεξιότερα" της $i (j > i$ δηλαδή) για την
    οποία ισχύει $c[j] < c[i]$. Εκτός από τις θέσεις $i$ οι οποίες "κυριαρχούν" όλων τον επόμενωντότε $c[i]=i$, αφού έτσι αρχικοποιήσαμε τον πίνακα (για ευκολία αργότερα). Η πολυπλοκότητα του αλγορίθμου είναι $O(n)$. Ο αλγόριθμος του προβλήματος παρουσιάζεται παρακάτω. Πιο συγκεκριμένα σαν μια ρουτίνα (η απάντηση είναι $MinCostToTravel(1,0)$).\\
    $MinCostToTravel(i,rank):$\\
    $\hookrightarrow cost \leftarrow 0$ \\
    Αν μπορούμε να φθάσουμε στον προορισμό τελειώσαμε. Ο πίνακας $CostFromStart$ μπορεί να υπολογιστεί σε χρόνο $Θ(n)$ ως ένα κινούμενο άθροισμα.\\
    - Αν $tank \geq CostFromStart[t] - CostFromStart[u_i]$, τότε: Επέστρεψε 0\\
    Αν δεν υπάρχουν φθηνότερα βενζινάδικα στην πορεία ή το επόμενο φθηνότερο είναι πιο μακριά
    από την αυτονομία μας, τότε γεμίζουμε το ντεπόζιτο και εκτελούμε τον ίδιο αλγόριθμο στην αμέσως επόμενη πόλη.\\
    - Αν $d[i] = i$  ή $tank < CostFromStart[t] -CostFromStart[u_i]$, τότε: \\
    •$cost \leftarrow cost + (B-tank)c_i$\\
    • $tank \leftarrow B$\\
    • Επέστρεψε $cost + MinCostToTravel(i+1,B-b(i,i+1))$\\
    Αλλιώς γεμίζουμε το ντεπόζιτο (αν χρειάζεται) ώστε να αρκεί ακριβώς για να φθάσουμε στην επόμενη φθηνότερη πόλη και συνεχίζουμε από αυτήν.\\
    - Αν $i <n $:\\
    • Για $i$ από $i$ μέχρι $d[i]$:\\
    – Αν $tank > b(u_,u_{i+1})$, τότε: $tank \leftarrow fuel -b(u_j,u_{j+1})$\\
    – Αλλιώς:\\ 
    •$buy \leftarrow b(u_j,u_{j+1}) -tank$\\
    •$tank \leftarrow 0$\\
    •$cost \leftarrow cost+c[i]buy$\\
    • Επέστρεψε \texten{cost + MinCostToTravel(d[i],0)}\\
    $\hookrightarrow$ Επέστρεψε 0.\\
    Η πολυπλοκότητα του αλγορίθμου είναι γραμμική: $Θ(n)$.\\
    Η ορθότητα του βασίζεται στα εξής επιχειρήματα:\\
    - Αν μπορούμε να φθάσουμε στον προορισμό με την υπολειπόμενη βενζίνη τελειώσαμε.\\
    - Αν βρισκόμαστε σε μια πόλη όπου η αμέσως επόμενη φθηνότερη είναι η $u_j$ τότε γεμίζουμε το ντεπόζιτο ακριβώς ώστε να φθάσουμε εκεί.\\
    - Αν δεν επαρκεί το ντεπόζιτο για να φθάσουμε εκεί ή δεν έπονται φθηνότερες πόλεις γεμίζουμε το ντεπόζιτο και επαναλαμβάνουμε την διαδικασία στην επόμενη πόλη.\\
    Θα αποδείξουμε ότι αυτός ο άπληστος αλγόριθμος παράγει την βέλτιστη λύση. Το άπληστο κριτήριο αποτελούν τα τρία παραπάνω βήματα. Είναι προφανές ότι αν μια λύση δεν ακολουθεί το πρώτο δεν μπορεί να είναι βέλτιστη, οπότε προχωράμε στο δεύτερο. Αν
    ισχύει η συνθήκη του δεύτερου βήματος, τότε μια λύση που δεν το ακολουθεί θα πρέπει να αγοράζει βενζίνη σε κάποια ενδιάμεση πόλη (πριν την $u_j$ και μετά την αρχική),ώστε να φθάσει εκει (αν δεν υπάρχουν ενδιάμεσες τότε και οι δύο λύσεις απαιτούνται να αγοράσουν όση χρειάζεται για να πάνε από την αρχική στην επόμενη). Αν σε αυτή την λύση "αφαιρέσουμε" κάποια ποσότητα βενζίνης που αγοράσθηκε στην ενδιάμεση πόλη και την αγοράσουμε στην αρχική, τότε έχουμε μικρότερο κόστος. Η ίδια τεχνική ανταλλαγής μπορεί να χρησιμοποιηθεί και και για την ορθότητα του τρίτου βήματος. Άρα ο αλγόριθμος μας παράγει την βέλτιστη λύση.
    \item Για την γενική περίπτωση όπου το $G$ είναι γράφος θα χρησιμοποιήσουμε δυναμικό
    προγραμματισμό. Έστω $C(u,b)$ το ελάχιστο κόστος για να μεταβούμε από την πόλη $u$στην
    $t$ έχοντας αρχικά $b$ λίτρα βενζίνης. Τότε:\\
    \begin{center}
      \[ C(u,b) = min_{v\in OutAdjList(u)}
      \left\{
      \begin{array}{ll}
        C(v,0)+c(u)[b(u,u)-b] & c(v) < c(u) \text{ και } b \leq b(v,u) \\
        C(v,B-b(u,v))+c(u)(B-b) & c(v)>c(u)\\
        0 & u=t\\
        \inf \text{αλλιώς}
      \end{array} 
      \right\}. 
      \]
    \end{center}
    Μπορούμε να αποδείξουμε ότι σε μια διαδρομή βέλτιστου κόστους όπου οι στάσεις σε
βενζινάδικα γίνονται στις πόλεις $i,i+1,...,k$ τότε πρέπει:\\
- Αν $c(i) \geq c(j)$ τότε "γεμίζουμε" μέχρι να φτάσουμε με ακριβώς 0 βενζίνη στην $j$.\\
- Αν ισχύει το αντίθετο, τότε γεμίζουμε το ντεπόζιτο.\\
Απόδειξη:\\
Αν "αγοράσουμε" παραπάνω στην πόλη $i$ ενώ ισχύει $c(i) \geq c(j)$, τότε θα μπορούσαμε να
αφαιρέσουμε από αυτό που αγοράσαμε "περαιτέρω" στην πρώτη πόλη και να αγοράσουμε
το ίδιο ποσό βενζίνης στην επόμενη με ίσο ή μικρότερο κόστος. Παρόμοια απόδειξη και
για τον δεύτερο ισχυρισμό. \\ \\
Απομένει να υπολογίσουμε την πολυπλοκότητα του αλγορίθμου. Αρχικά θα αποδείξουμε
ότι χρειαζόμαστε μόνο συγκεκριμένες τιμές του $b$. Έστω $z \neq s$ μια κορυφή όπου αγοράζουμε βενζίνη στη βέλτιστη λύση και $u$ η προηγούμενη της. Τότε με βάση τον αλγόριθμο
θα φτάσουμε στην $z$ με βενζίνη στο σύνολο: $B-b(u,z)|u \in IncAdjList(z)\{0\}$, δηλαδή θα
μπορούσε να πάρει το πολύ $|V|$ τιμές. Άρα εφόσον χρειαζόμαστε το $D(u,g)$
για κάθε πιθανό $u$($|V|$ κορυφές) και πιθανό $g$ (το πολύ $|V|$ τιμές για κάθε κορυφή), αυτό
εξαρτάται από το πολύ $|V|$ γείτονες της $u$. Επομένως η πολυπλοκότητα είναι $O(|V|^3)$.
\end{enumerate}
\newpage

\section*{Ζητούμενο 6: Ενοικίαση Αυτοκινήτων}

\par Προκείμενου να λυθεί αυτό το πρόβλημα θα χρησιμοποιήσουμε αναγωγή στο \texten{max flow min cost problem}. Αρχικά το πρόβλημα έχει ένα \texten{source node s} και έναν \texten{target node t} που
συμβολίζουν την αρχή και το τέλος του προβλήματος ροής, δηλαδή το πέρας του μεγαλύτερου $t_i$ και του τελευταίου πελάτη- προσφοράς.
\par Υπάρχουν n κόμβοι τύπου s που συμβολίζουν την αρχή του χρονικού διαστήματος κάθε
πελάτη και n κόμβοι τύπου t που συμβολίζουν το πέρας αυτού. Οι πρώτοι συνδέονται με
ακμές με τον source node και οι δεύτεροι συνδέονται με τον target node του γράφου.
\par Οι ακμές που συνδέουν τους κόμβους $s_i$ και $t_i$ έχουν αρνητικά κόστη -pi που συμβολίζουν την επιλογή ενός πελάτη για ενοικίαση αυτοκινήτου. Κάθε άλλη ακμή (από τον source node και προς τον \texten{sink node}) έχει κόστος 0 καθώς δεν συμβολίζει ενοικίαση κάποιο αυτοκινήτου. ΄Ολες οι ακμές έχουν διαθέσιμο flow ίσο με 1.
\par Επίσης, συνδέω κάθε κορυφή $t_j$ με κάθε κορυφή si αν ισχύει $t_j < s_i$ , δηλαδή αν έχω
χρονική επικάλυψη σε οποιαδήποτε δύο ζεύγη διαστημάτων. Αυτές οι ακμές έχουν
πάλι flow 1 και cost 0 αφού αντιστοιχούν στην επιλογή του πελάτη i αφού έχει προηγηθεί η
έναρξη του πελάτη j.
\par Στόχος μας τώρα είναι να λύσουμε το min cost-max flow problem στον γράφο του
σχήματος. Το min cost θα είναι το ελάχιστο άθροισμα αρνητικών pi και άρα ισοδυναμεί με
την μεγιστοποίηση του κέρδους της εταιρείας. Προκειμένου να βρούμε το min
cost λοιπόν, αρχικοποιούμε την ροή που θέλουμε να "περάσουμε" από τον γράφο σε k.
\par ΄Εχω $O(n)$ κορυφές και $O(n^2)$ ακμές άρα complexity με \texten{Bellman Ford} χωρίς βελτιώσεις $O(nmd) = O(n^3k)$. Αν τον επιταχύνουμε με χρήση κωδικοποιημένων μονοπατιών Dijkstra
μπορεί να γίνει $O(kn^2logn)$.
\begin{figure}[h]
  \includegraphics[width=10cm,height=6cm]{Screenshot 2023-12-29 at 20.14.34.png}
  \centering
\end{figure}

\end{document}
